<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chaotic Glowing Triple Pendulum</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  canvas{display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const dpr = window.devicePixelRatio || 1;
  function resize() {
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize",resize);
  resize();

  const origin = {x: innerWidth/2, y: 150};
  const g = 980; 
  const dt = 1/60;
  const constraintIters = 8;

  const segs = [
    {length: 180, mass: 1},
    {length: 150, mass: 1},
    {length: 120, mass: 1}
  ];
  const colors = ["#ff4444","#44ff88","#4488ff"];
  const bobs = [];

  function makeBob(x,y,m){return {x,y,px:x,py:y,m,r:12}}
  function init(){
    let x=origin.x, y=origin.y;
    [1.2,0.9,1.5].forEach((a,i)=>{
      x+=Math.sin(a)*segs[i].length;
      y+=Math.cos(a)*segs[i].length;
      bobs[i]=makeBob(x,y,segs[i].mass);
    });
    // inject chaotic motion by shifting previous positions
    for(let b of bobs){
      b.px = b.x - (Math.random()*100-50);
      b.py = b.y - (Math.random()*100-50);
    }
  }
  init();

  function integrate(){
    for(let b of bobs){
      const ax=0, ay=g;
      const nx = b.x + (b.x-b.px) + ax*dt*dt;
      const ny = b.y + (b.y-b.py) + ay*dt*dt;
      b.px=b.x; b.py=b.y;
      b.x=nx; b.y=ny;
    }
  }
  function satisfy(a,b,L){
    if(!a){
      let dx=b.x-origin.x, dy=b.y-origin.y;
      let d=Math.hypot(dx,dy)||1e-6;
      let diff=(d-L)/d;
      b.x-=dx*diff; b.y-=dy*diff;
      return;
    }
    let dx=b.x-a.x, dy=b.y-a.y;
    let d=Math.hypot(dx,dy)||1e-6;
    let diff=(d-L)/d;
    let w=1/a.m+1/b.m;
    a.x+=dx*diff*(1/a.m)/w;
    a.y+=dy*diff*(1/a.m)/w;
    b.x-=dx*diff*(1/b.m)/w;
    b.y-=dy*diff*(1/b.m)/w;
  }

  function drawBob(b,color){
    // glowing halo
    let halo=ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r*5);
    halo.addColorStop(0,color);
    halo.addColorStop(1,"transparent");
    ctx.fillStyle=halo;
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r*5,0,2*Math.PI);
    ctx.fill();

    // bright core
    let g=ctx.createRadialGradient(b.x,b.y,0,b.x,b.y,b.r);
    g.addColorStop(0,"#fff");
    g.addColorStop(0.5,color);
    g.addColorStop(1,color);
    ctx.shadowBlur=25; ctx.shadowColor=color;
    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(b.x,b.y,b.r,0,2*Math.PI);
    ctx.fill();
    ctx.shadowBlur=0;
  }
  function drawRod(ax,ay,bx,by,color){
    ctx.shadowBlur=12; ctx.shadowColor=color;
    ctx.strokeStyle=color; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    ctx.shadowBlur=0;
  }

  function animate(){
    for(let s=0;s<2;s++){ // 2 substeps for stability
      integrate();
      for(let i=0;i<constraintIters;i++){
        satisfy(null,bobs[0],segs[0].length);
        satisfy(bobs[0],bobs[1],segs[1].length);
        satisfy(bobs[1],bobs[2],segs[2].length);
      }
    }

    // fade canvas slowly for glowing trails
    ctx.fillStyle="rgba(0,0,0,0.2)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw rods
    drawRod(origin.x,origin.y,bobs[0].x,bobs[0].y,colors[0]);
    drawRod(bobs[0].x,bobs[0].y,bobs[1].x,bobs[1].y,colors[1]);
    drawRod(bobs[1].x,bobs[1].y,bobs[2].x,bobs[2].y,colors[2]);

    // draw bobs
    bobs.forEach((b,i)=>drawBob(b,colors[i]));

    requestAnimationFrame(animate);
  }
  animate();
})();
</script>
</body>
</html>
